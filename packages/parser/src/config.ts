import type { traverse } from '@humanwhocodes/momoa';
import { merge } from 'merge-anything';
import type { LintRuleShorthand, LintRuleLonghand, LintNotice, LintRule } from './lint/index.js';
import Logger from './logger.js';

const TRAILING_SLASH_RE = /\/*$/;

export interface Config {
  /** Path to tokens.json (default: "./tokens.json") */
  tokens?: string | string[];
  /** Output directory (default: "./tokens/") */
  outDir?: string;
  /** Specify plugins */
  plugins?: Plugin[];
  /** Specify linting settings */
  lint?: {
    /** Configure build behavior */
    build?: {
      /** Should linters run with `co build`? (default: true) */
      enabled?: boolean;
    };
    /** Configure lint rules */
    rules?: Record<string, LintRuleShorthand | LintRuleLonghand>;
  };
}

export interface ConfigInit {
  tokens: URL[];
  outDir: URL;
  plugins: Plugin[];
  lint: {
    build: NonNullable<NonNullable<Config['lint']>['build']>;
    rules: Record<string, LintRule>;
  };
}

export interface Plugin {
  name: string;
  /** (optional) Read config, and optionally modify */
  // biome-ignore lint/suspicious/noConfusingVoidType format: this helps plugins be a little looser on their typing
  config?(config: ConfigInit): void | ConfigInit | undefined;
  /** (optional) Register lint rule IDs */
  registerRules?(): Omit<LintRule, 'options'>[];
  /** (optional) Throw lint errors/warnings */
  lint?(options: PluginLintStageOptions): Promise<LintNotice[] | undefined>;
  /** Main build fn */
}

export interface PluginLintStageOptions {
  /**
   * The rules this plugin registered will be returned here, along with the user’s preset `severity` ("off" if they’ve disabled it)
   */
  rules: LintRule[];
  /**
   * Traversable AST generated by Momoa (gives you a way to point to the code that erred)
   */
  traverse: (visitor: any) => void;
}

export interface ConfigOptions {
  logger?: Logger;
  /** Configs need CWD so this can be run without Node.js */
  cwd: URL;
}

/**
 * Validate and normalize a config
 */
export default function validateAndNormalizeConfig(
  rawConfig: Config,
  { logger = new Logger(), cwd }: ConfigOptions,
): ConfigInit {
  const configStart = performance.now();

  logger.debug({ group: 'core', task: 'config', message: 'Start config validation' });

  let config = { ...(rawConfig as any) } as ConfigInit;

  // config.tokens
  if (rawConfig.tokens === undefined) {
    config.tokens = ['./tokens.json' as any]; // will be normalized in next step
  } else if (typeof rawConfig.tokens === 'string') {
    config.tokens = [rawConfig.tokens as any]; // will be normalized in next step
  } else if (Array.isArray(rawConfig.tokens)) {
    config.tokens = [];
    for (const file of rawConfig.tokens) {
      if (typeof file === 'string') {
        config.tokens.push(file as any); // will be normalized in next step
      } else {
        logger.error({
          label: 'config.tokens',
          message: `Expected array of strings, encountered ${JSON.stringify(file)}`,
        });
      }
    }
  } else {
    logger.error({
      label: 'config.tokens',
      message: `Expected string or array of strings, received ${typeof rawConfig.tokens}`,
    });
  }
  for (let i = 0; i < config.tokens.length; i++) {
    const filepath = config.tokens[i] as any as string;
    const isRemote = filepath.startsWith('//') || filepath.startsWith('http:') || filepath.startsWith('https:');
    if (isRemote) {
      try {
        config.tokens[i] = new URL(filepath);
      } catch {
        logger.error({ label: 'config.tokens', message: `Invalid URL ${filepath}` });
      }
    }
  }

  // config.outDir
  if (rawConfig.outDir === undefined) {
    config.outDir = new URL('./tokens/', cwd);
  } else if (typeof rawConfig.outDir !== 'string') {
    logger.error({ label: 'config.outDir', message: `Expected string, received ${JSON.stringify(rawConfig.outDir)}` });
  } else {
    // note: always add trailing slash so URL treats it as a directory
    config.outDir = new URL(rawConfig.outDir.replace(TRAILING_SLASH_RE, '/'), cwd);
  }

  // config.plugins
  if (rawConfig.plugins !== undefined) {
    if (!Array.isArray(rawConfig.plugins)) {
      logger.error({
        label: 'config.plugins',
        message: `Expected array of plugins, received ${JSON.stringify(config.plugins)}`,
      });
    }
    for (let n = 0; n < rawConfig.plugins.length; n++) {
      const plugin = rawConfig.plugins[n];
      if (typeof plugin !== 'object') {
        logger.error({ label: `plugin[${n}]`, message: `Expected output plugin, received ${JSON.stringify(plugin)}` });
      } else if (!plugin.name) {
        logger.error({ label: `plugin[${n}]`, message: `Missing "name"` });
      }
    }
  }
  if (Array.isArray(config.plugins) && config.plugins.length) {
    for (const plugin of config.plugins) {
      if (typeof plugin.config === 'function') {
        const newConfig = plugin.config(config); // if a plugin modified the config, allow it to
        if (newConfig) {
          config = newConfig;
        }
      }
    }
  }

  // config.lint
  if ('lint' in config && config.lint !== undefined) {
    if (config.lint === null || typeof config.lint !== 'object' || Array.isArray(config.lint)) {
      logger.error({ label: 'config.lint', message: 'Must be an object' });
      return config;
    }

    if (!(('build' in config.lint) as any)) {
      config.lint.build = { enabled: true };
    }
    if ('enabled' in config.lint.build && config.lint.build.enabled !== undefined) {
      if (typeof config.lint.build.enabled !== 'boolean') {
        logger.error({
          label: 'config.lint.build.enabled',
          message: `Expected boolean, received ${JSON.stringify(config.lint.build)}`,
        });
      }
    } else {
      config.lint.build.enabled = true;
    }

    if ('rules' in config.lint && config.lint.rules !== undefined) {
      if (config.lint.rules === null || typeof config.lint.rules !== 'object' || Array.isArray(config.lint.rules)) {
        logger.error({
          label: 'config.lint.rules',
          message: `Expected object, received ${JSON.stringify(config.lint.rules)}`,
        });
      }

      for (const id in config.lint.rules) {
        if (typeof id !== 'string') {
          logger.error({ label: 'config.lint.rules', message: `Expects string keys, received ${JSON.stringify(id)}` });
        }
        const value = config.lint.rules[id] as unknown;
        let severity: number | string = 'off';
        let options: unknown | undefined;
        if (typeof value === 'number' || typeof value === 'string') {
          severity = value;
        } else if (Array.isArray(value)) {
          severity = value[0];
          options = value[1];
        } else if (value !== undefined) {
          logger.error({
            label: `config.lint.rule:${id}`,
            message: `Invalid eyntax. Expected \`string | number | Array\`, received ${JSON.stringify(value)}}`,
          });
        }
        config.lint.rules[id] = { id, severity: severity as LintRule['severity'], options };
        if (typeof severity === 'number') {
          if (severity !== 0 && severity !== 1 && severity !== 2) {
            logger.error({
              label: `config.lint.rule:${id}`,
              message: `Invalid number ${severity}. Specify 0 = "off", 1 = "warn", or 2 = "error".`,
            });
            return config;
          }
          config.lint.rules[id]!.severity = (['off', 'warn', 'error'] as const)[severity];
        } else if (typeof severity === 'string') {
          if (severity !== 'off' && severity !== 'warn' && severity !== 'error') {
            logger.error({
              label: `config.lint.rule:${id}`,
              message: `Invalid string ${JSON.stringify(severity)}. Specify "off", "warn", or "error".`,
            });
          }
        } else if (value !== null) {
          logger.error({
            label: `config.lint.rule:${id}`,
            message: `Expected string or number, received ${JSON.stringify(value)}`,
          });
        }
      }
    }
  } else {
    config.lint = {
      build: { enabled: true },
      rules: {},
    };
  }

  logger.debug({
    group: 'core',
    task: 'config',
    message: 'Finish config validation',
    timing: performance.now() - configStart,
  });

  return config;
}

export function mergeConfigs(a: Config, b: Config) {
  return merge(a, b);
}
